# 说明 - Vulkan草地渲染

本作业**截止日期为10月29日星期二晚上11:59**。

**快速提示**：克隆此仓库时请使用`git clone --recursive`，因为其中包含需要一同克隆的子模块。

## 概述

在这个项目中，你将使用Vulkan实现一个草地模拟器和渲染器。你将使用计算着色器对表示单个草叶的贝塞尔曲线进行物理计算。由于在每一帧渲染所有草叶效率较低，你还将使用计算着色器剔除那些对当前帧没有贡献的草叶。剩余的草叶将传递给图形管线，你将在其中编写多个着色器。你将编写顶点着色器来变换贝塞尔控制点，曲面细分着色器从贝塞尔曲线动态创建草地几何体，以及片段着色器为草叶着色。

提供的基础代码包括所有基本的Vulkan设置，包括一个运行计算着色器的计算管线和两个图形管线，一个用于渲染放置草地的几何体，另一个用于渲染草地本身。你的任务是为草地图形管线和计算管线编写着色器，并绑定任何你可能需要的资源（描述符）以完成本作业中描述的任务。

![](img/grass.gif) ![](img/grass2.gif)

如果你不想使用这些基础代码，你可以不使用。你也可以随意更改基础代码的任何部分。

**这是你自己的项目。** 上面的GIF仅作为参考示例供你比较。请随意发挥创意实现你的方案！

## 内容

* `src/` C++/Vulkan源文件。
  * `shaders/` glsl着色器源文件
  * `images/` 在图形管线中用作纹理的图像
* `external/` 第三方库的包含文件和静态库。
* `img/` 在README中使用的截图和图像

## 安装Vulkan

要运行Vulkan项目，你首先需要下载并安装[Vulkan SDK](https://vulkan.lunarg.com/)。确保以管理员身份运行安装程序，以便安装程序能为你设置适当的环境变量。

完成后，你需要确保你的GPU驱动支持Vulkan。从NVIDIA网站下载并安装[Vulkan驱动](https://developer.nvidia.com/vulkan-driver)。

最后，为了检查Vulkan是否准备就绪，前往你的Vulkan SDK目录（除非另有说明，否则为`C:/VulkanSDK/`），并运行`Bin`目录中的`vkcube.exe`示例。如果你看到一个带有LunarG标志的旋转灰色立方体，那么你就准备好了！

## 运行代码

在开发草地渲染器时，你会希望保持验证层启用，以便进行错误检查。该项目设置为当你处于`debug`模式时，验证层被启用，当你处于`release`模式时，验证层被禁用。构建代码后，你应该能够运行项目而不会出现任何错误。一开始你会看到一个带有草地纹理的平面。

![](img/cube_demo.png)

## 要求

**如有任何不清楚的地方，请在Piazza上提问。**

在这个项目中，你获得了以下代码：

* Vulkan项目的基本设置，包括交换链、物理设备、逻辑设备和上述描述的管线。
* 你将使用的一些统一缓冲区的结构体。
* 一些缓冲区创建工具函数。
* 使用鼠标的简单交互式摄像机。

你需要实现以下功能/管线阶段：

* 计算着色器（`shaders/compute.comp`）
* 草地管线阶段
  * 顶点着色器（`shaders/grass.vert`）
  * 曲面细分控制着色器（`shaders/grass.tesc`）
  * 曲面细分评估着色器（`shaders/grass.tese`）
  * 片段着色器（`shaders/grass.frag`）
* 绑定你可能需要的任何额外描述符

更多指导见下文。

## 基础代码导览

需要完成的区域标有`TODO`注释。对参考有用的函数标有`CHECKITOUT`注释。

* `src/main.cpp`是我们应用程序的入口点。
* `src/Instance.cpp`设置应用程序状态，初始化Vulkan库，并包含创建物理和逻辑设备句柄的函数。
* `src/Device.cpp`管理逻辑设备并设置我们的命令缓冲区将提交到的队列。
* `src/Renderer.cpp`包含大部分渲染实现，包括Vulkan设置和资源创建。你可能需要对此文件进行更改以支持管线的变化。
* `src/Camera.cpp`管理摄像机状态。
* `src/Model.cpp`管理将要创建草地的模型状态。目前硬编码了一个平面，但可以随意更新为任意模型加载！
* `src/Blades.cpp`创建对应于草叶的控制点。这里有很多参数可以调整，这些参数会改变渲染草叶的行为。
* `src/Scene.cpp`管理场景状态，包括模型、草叶和模拟时间。
* `src/BufferUtils.cpp`提供用于创建作为描述符使用的缓冲区的辅助函数。

我们省略了一些你可能不需要修改的文件的描述。请随时研究它们以了解它们在项目范围内的重要性。

## 草地渲染

这个项目是对论文[《通用3D场景的响应式实时草地渲染》](https://www.cg.tuwien.ac.at/research/publications/2017/JAHRMANN-2017-RRTG/JAHRMANN-2017-RRTG-draft.pdf)的实现。

在实现草地渲染器时，请确保使用这篇论文作为主要资源。它很好地解释了你将使用的关键算法和数学。以下是渲染器执行顺序中各个组件的简要描述，但你可以按照自己喜欢的顺序开发这些组件。

我们建议从尝试显示没有任何力作用的草叶开始，然后再尝试在草叶上添加力。以下是这可能的效果示例：

![](img/grass_basic.gif)

### 将草表示为贝塞尔曲线

在这个项目中，草叶将在执行物理计算和剔除操作时表示为贝塞尔曲线。

每条贝塞尔曲线有三个控制点。
* `v0`：草叶在几何体上的位置
* `v1`：贝塞尔曲线引导点，相对于草叶的向上向量（稍后解释）始终在`v0`"之上"
* `v2`：我们模拟受力的物理引导点

我们还需要存储每个草叶的特性，这将帮助我们正确地模拟和细分草叶。
* `up`：草叶的向上向量，对应于草叶所在几何体在`v0`处的法线
* 方向：草叶面的方向
* 高度：草叶的高度
* 宽度：草叶面的宽度
* 刚度系数：草叶的刚度，这将影响草叶上的力计算

我们可以将所有这些数据打包到四个`vec4`中，使得`v0.w`存储方向，`v1.w`存储高度，`v2.w`存储宽度，`up.w`存储刚度系数。

![](img/blade_model.jpg)

### 模拟力

在这个项目中，你将在草叶仍然是贝塞尔曲线时对其进行力的模拟。这将使用为你创建的计算管线在计算着色器中完成。记住`v2`是我们的物理引导点，所以我们首先对`v2`应用变换，然后纠正潜在的错误。最后，我们将更新`v1`以保持草叶的适当长度。

#### 绑定资源

为了在每一帧更新草叶的状态，你需要创建一个存储缓冲区来维护草地数据。你还需要传递有关模拟中经过的时间和自上一帧以来的时间的信息。为此，你可以扩展或创建将绑定到计算管线的描述符集。

#### 重力

给定重力方向`D.xyz`和加速度大小`D.w`，我们可以计算场景中的环境重力为`gE = normalize(D.xyz) * D.w`。

然后我们确定重力相对于草叶正面方向`f`的贡献，这被称为"前向重力"。前向重力计算为`gF = (1/4) * ||gE|| * f`。

然后我们可以确定草叶上的总重力为`g = gE + gF`。

#### 恢复

恢复对应于使草叶回到平衡状态的反作用力。这在论文中使用胡克定律推导。为了确定恢复力，我们需要比较`v2`的当前位置与模拟开始前的原始位置`iv2`。在模拟开始时，`v1`和`v2`初始化为沿`up`向量的草叶高度距离。

一旦我们有了`iv2`，我们就可以计算恢复力为`r = (iv2 - v2) * stiffness`。

#### 风

为了模拟风，你可以自由创建任何你想要的风函数！为了使其有趣，你可以让函数依赖于`v0`的位置和随时间变化的函数。考虑使用正弦或余弦函数的组合。

你的风函数将确定影响草叶的风向，但值得注意的是，风对其前向方向与风向平行的草叶影响更大。论文将此描述为"风对齐"项。我们在这里不会详细介绍确切的数学，但在实现时请参考论文。它在解释这一点方面做得很好！

一旦你有了风向和风对齐项，你的总风力（`w`）将是`windDirection * windAlignment`。

#### 总力

然后我们可以根据力确定`v2`的平移为`tv2 = (gravity + recovery + wind) * deltaTime`。然而，我们不能简单地应用这个平移并期望模拟是稳健的。我们的力可能会将`v2`推到地面以下！同样，移动`v2`但保持`v1`在相同位置会导致我们的草叶改变长度，这没有意义。

阅读论文的5.2节，了解如何确定`v1`和`v2`的校正最终位置。

### 剔除测试

虽然我们需要在每一帧对每个草叶进行力的模拟，但由于各种原因，许多草叶我们不需要渲染。以下是我们可以用来剔除不会对给定帧产生积极贡献的草叶的一些启发式方法。

#### 方向剔除

考虑草叶的正面方向与视线向量垂直的情况。由于我们的草叶没有宽度，我们最终会尝试渲染实际上比像素大小还小的草的部分。这可能导致走样伪影。

为了解决这个问题，我们可以剔除这些草叶！只需进行点积测试，看看视线向量和草叶的正面方向是否垂直。论文使用了`0.9`的阈值来剔除，但请随意使用你认为最好的值。

#### 视锥剔除

我们还想剔除视锥之外的草叶，考虑到它们无论如何都不会出现在帧中。要确定草叶是否在视锥中，我们要比较三个点的可见性：`v0`、`v2`和`m`，其中`m = (1/4)v0 * (1/2)v1 * (1/4)v2`。

注意我们没有使用`v1`进行可见性测试。这是因为`v1`是一个贝塞尔引导点，不代表草叶上的位置。我们而是使用`m`来近似贝塞尔曲线的中点。

如果所有三个点都在视锥之外，我们将剔除草叶。论文为这个测试使用了容差值，这样我们就可以更保守地剔除草叶。这可以帮助处理贝塞尔曲线技术上不可见，但如果考虑其宽度，我们可能能够看到草叶的情况。

#### 距离剔除

与方向剔除类似，在较大距离处，我们可能会遇到比像素大小还小的草叶。这可能导致我们的渲染中出现额外的伪影。在这种情况下，我们可以根据草叶与摄像机的距离剔除草叶。

这里你可以自由定义两个参数。
* 一个最大距离，超过该距离的所有草叶都将被剔除。
* 将摄像机和最大距离之间的草叶放入的桶数。

定义一个函数，使得最靠近摄像机的桶中的草叶被保留，而随着桶越远，越多的草叶被剔除。

#### 遮挡剔除（额外学分）

这种类型的剔除只有在我们的场景中除了平面和草叶外还有其他物体时才有意义。我们想要剔除被其他几何体遮挡的草叶。想想你如何使用深度图来完成这个任务！

### 将贝塞尔曲线细分为草叶

在这个项目中，你应该将每条贝塞尔曲线作为单个面片传递给草地图形管线进行处理。你将把这个面片细分成一个四边形，形状可以自行选择（当然，只要它看起来足够像草）。论文中有一些草的形状例子，你可以用作灵感。

在曲面细分控制着色器中，指定你想要进行的细分量。记住，你需要提供足够的细节来创建草叶的曲率。

生成的顶点将被传递到曲面细分评估着色器，在那里你将把顶点放置在世界空间中，尊重每个草叶的宽度、高度和方向信息。一旦你确定了每个向量的世界空间位置，确保将输出`gl_Position`设置在裁剪空间中！

**额外学分**：根据草叶与摄像机的距离函数，细分到不同的细节级别。例如，如果草叶非常远，则在曲面细分控制着色器中只生成四个顶点。

为了更好地理解曲面细分的工作原理，我强烈建议你使用[helloTessellation示例](https://github.com/CIS565-Fall-2017/Vulkan-Samples/tree/master/samples/5_helloTessellation)并阅读这篇[关于曲面细分的教程](https://ogldev.org/www/tutorial30/tutorial30.html)。

## 资源

### 链接

以下资源可能对这个项目有用。

* [通用3D场景的响应式实时草地渲染](https://www.cg.tuwien.ac.at/research/publications/2017/JAHRMANN-2017-RRTG/JAHRMANN-2017-RRTG-draft.pdf)
* [CIS565 Vulkan示例](https://github.com/CIS565-Fall-2017/Vulkan-Samples/tree/master/samples/5_helloTessellation)
* [官方Vulkan文档](https://www.khronos.org/registry/vulkan/)
* [Vulkan教程](https://vulkan-tutorial.com/)
* [RenderDoc关于Vulkan的博客](https://renderdoc.org/vulkan-in-30-minutes.html)
* [曲面细分教程](https://ogldev.org/www/tutorial30/tutorial30.html)


## 第三方代码政策

* 使用任何第三方代码必须通过在Piazza上询问获得批准。
* 如果获得批准，所有学生都可以使用它。通常，我们批准使用不属于项目核心部分的第三方库。例如，对于路径追踪器，我们会批准使用第三方库来加载模型，但不会批准复制和粘贴用于执行折射的CUDA函数。
* 第三方代码**必须**在README.md中注明来源。
* 未经批准使用第三方代码，包括使用其他学生的代码，是违反学术诚信的行为，至少会导致你在本学期获得F的成绩。

## README

* 项目的简要描述和你实现的具体功能。
* 你的项目在不同阶段的GIF，展示不同功能的逐步添加。
* 性能分析（如下所述）。

### 性能分析

性能分析是你将调查...
* 你的渲染器如何处理不同数量的草叶
* 使用三种剔除测试中的每一种进行剔除所获得的改进

## 提交

如果你修改了任何`CMakeLists.txt`文件（除了`SOURCE_FILES`列表外），请明确提及。注意Piazza上讨论的任何构建问题。

打开GitHub拉取请求，以便我们看到你已经完成。
* 标题应为"Project 5: YOUR NAME"。
* 拉取请求评论部分的模板如下所示，你可以进行一些复制和粘贴：  
  * [仓库链接](https://link-to-your-repo)
  * （简要）提及你已完成的功能。特别是那些你想要强调的铃铛和口哨
    * 功能0
    * 功能1
    * ...
  * 对项目本身的反馈，如果有的话。 